mod cartridge;
mod ppu;
mod mmu;
mod cpu;
mod gb;

use gb::GB;
use cartridge::Cartridge;

use sdl2::pixels::PixelFormatEnum;
use sdl2::event::Event;
use sdl2::keyboard::Scancode;

const INPUT_MASKS: [(Scancode, u8); 8] = [
    (Scancode::Right,  gb::BTN_RIGHT),
    (Scancode::Left,   gb::BTN_LEFT),
    (Scancode::Up,     gb::BTN_UP),
    (Scancode::Down,   gb::BTN_DOWN),
    (Scancode::Z,      gb::BTN_A),
    (Scancode::X,      gb::BTN_B),
    (Scancode::Space,  gb::BTN_SELECT),
    (Scancode::Return, gb::BTN_START),
];

/// This main module uses the SDL2 library as an interface between the emulator core and the user.
/// SDL handles:
///   - Providing the frame buffer that acts as the display, rendering frames generated by the emulator.
///   - Capturing user input (keyboard presses) and mapping them to the emulated CPU's button signals.
///   - Managing the window and vertical synchronization (VSync) for smooth visual output.
/// The emulator core (CPU, PPU, MMU, etc.) does not directly depend on SDL;
/// this layer is responsible for handling visual output and user controls.
fn main() {
    let rom_path = "tetris.gb";
    let cartridge = match Cartridge::from_file(rom_path) {
        Ok(cart) => cart,
        Err(e) => {
            eprintln!("Error loading ROM: {}", e);
            return;
        }
    };

    emulate(GB::new(cartridge));
}

fn emulate(mut gb: GB) {
    let sdl_context = sdl2::init().unwrap();
    let video_subsystem = sdl_context.video().unwrap();

    let window = video_subsystem
        .window(
            "RUSTÐ¯IS",
            (ppu::SCREEN_WIDTH as u32) * 4,
            (ppu::SCREEN_HEIGHT as u32) * 4,
        )
        .position_centered()
        .build()
        .unwrap();

    let mut canvas = window.into_canvas().present_vsync().build().unwrap();
    let texture_creator = canvas.texture_creator();
    let mut texture = texture_creator
        .create_texture_streaming(
            PixelFormatEnum::RGB24,
            ppu::SCREEN_WIDTH as u32,
            ppu::SCREEN_HEIGHT as u32,
        )
        .unwrap();

    let mut event_pump = sdl_context.event_pump().unwrap();
    let mut framebuffer =
        [0u8; (ppu::SCREEN_WIDTH as usize * ppu::SCREEN_HEIGHT as usize * 3)]; // 3 bytes por pixel (RGB)

    'running: loop {
        for event in event_pump.poll_iter() {
            match event {
                Event::KeyDown { scancode: Some(Scancode::Escape), repeat: false, .. } |
                Event::Quit { .. } => break 'running,

                Event::KeyDown { scancode: Some(Scancode::P), repeat: false, .. } => {
                    gb.toggle_palette();
                }

                Event::KeyDown { scancode: Some(sc), repeat: false, .. } => {
                    if let Some(mask) = INPUT_MASKS.iter().find(|(s, _)| *s == sc).map(|(_, m)| *m) {
                        gb.input_press(mask);
                    }
                }

                Event::KeyUp { scancode: Some(sc), .. } => {
                    if let Some(mask) = INPUT_MASKS.iter().find(|(s, _)| *s == sc).map(|(_, m)| *m) {
                        gb.input_release(mask);
                    }
                }

                Event::Window { win_event: sdl2::event::WindowEvent::FocusLost, .. } => {
                    gb.input_release(
                        gb::BTN_RIGHT | gb::BTN_LEFT | gb::BTN_UP | gb::BTN_DOWN |
                        gb::BTN_A | gb::BTN_B | gb::BTN_SELECT | gb::BTN_START
                    );
                }

                _ => {}
            }
        }

        if gb.step(&mut framebuffer) {
            texture
                .update(None, &framebuffer, ppu::SCREEN_WIDTH as usize * 3)
                .unwrap();
            canvas.copy(&texture, None, None).unwrap();
            canvas.present();
        }
    }
}
